#include "SPI_Modules.h"
#include <pthread.h>
#include <stdio.h>

//#define VERBOSE

int DE0_handle, Teensy_handle, SPI2_handle;
pthread_mutex_t spi_mutex;

// Converts words from big endian to little endian (and vice versa)
// https://codereview.stackexchange.com/questions/151049/endianness-conversion-in-c
static inline int32_t Reverse32(int32_t value) 
{
    return (((value & 0x000000FF) << 24) |
            ((value & 0x0000FF00) <<  8) |
            ((value & 0x00FF0000) >>  8) |
            ((value & 0xFF000000) >> 24));
}

int init_spi() {
    DE0_handle = lgSpiOpen(0, SPI_DE0, SPI_SPEED_HZ_DEFAULT, SPI_MODE_DEFAULT);
    Teensy_handle = lgSpiOpen(0, SPI_TEENSY, SPI_SPEED_HZ_DEFAULT, SPI_MODE_DEFAULT);
    pthread_mutex_init(&spi_mutex,NULL);
    return (DE0_handle < 0) | (Teensy_handle  < 0); 
}

void spi_close() {
    lgSpiClose(DE0_handle);
    lgSpiClose(Teensy_handle);
    pthread_mutex_destroy(&spi_mutex);
}

int test_spi() {

    char send1[5]; send1[0] = 0; // Test read
    char send2[] = {0x9F,0x05,0x04,0x03,0x02}; // Test write
    char send3[5]; send3[0] = 0x1F;
    char receive1[5]; char receive3[5];

    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(DE0_handle, send1, receive1, 5);
    lgSpiWrite(DE0_handle, send2, 5);
    lgSpiXfer(DE0_handle, send3, receive3, 5);
    pthread_mutex_unlock(&spi_mutex);

    uint8_t failure = 0;
    for (int i = 0; i < 5; i++)
    {
        if (receive1[i] != i) {
            printf("SPI test 1 failed : receive[%d] == %d != %d\n",i,receive1[i],i);
            failure = 1;
        }
    }
    if (receive3[0] != 0x00) {printf("SPI test 2 failed : receive1[%d] == %d != %d\n",0,receive3[0],0x00); failure |= 2;}
    if (receive3[1] != 0x05) {printf("SPI test 2 failed : receive1[%d] == %d != %d\n",1,receive3[1],0x05); failure |= 2;}
    if (receive3[2] != 0x04) {printf("SPI test 2 failed : receive1[%d] == %d != %d\n",2,receive3[2],0x04); failure |= 2;}
    if (receive3[3] != 0x03) {printf("SPI test 2 failed : receive1[%d] == %d != %d\n",3,receive3[3],0x03); failure |= 2;}
    if (receive3[4] != 0x02) {printf("SPI test 2 failed : receive1[%d] == %d != %d\n",4,receive3[4],0x02); failure |= 2;}
    return failure;
}

// ----- SPI 2 ------

uint8_t init_spi2() {
    int SPI2_handle = lgGpiochipOpen(4);
    if (SPI2_handle < 0) return 1;
    if (lgGpioSetUser(SPI2_handle, "Bot Lightyear") < 0) return 2;

    claim_gpio(StprSliderGPIO); 
    claim_gpio(StprPlateGPIO); 
    claim_gpio(StprFlapsGPIO); 
    claim_gpio(BpSwitchFlapsLeftGPIO); 
    claim_gpio(BpSwitchFlapsRightGPIO); 
    return 0;
}

void spi_close2() {
    free_gpio(StprSliderGPIO); 
    free_gpio(StprPlateGPIO); 
    free_gpio(StprFlapsGPIO); 
    free_gpio(BpSwitchFlapsLeftGPIO); 
    free_gpio(BpSwitchFlapsRightGPIO); 
    lgGpiochipClose(SPI2_handle);
}

uint8_t claim_gpio(uint8_t gpio_pin) {
    if (lgGpioClaimInput(SPI2_handle, LG_SET_PULL_NONE, gpio_pin) != 0) return 1;
    return 0;
}

void free_gpio(uint8_t gpio_pin) {
    lgGpioFree(SPI2_handle, gpio_pin);
}

// ----- Odometers -----

void odo_get_tick(int32_t *tick_left, int32_t *tick_right) {

    char sendl[5]; sendl[0] = 0x01;
    char sendr[5]; sendr[0] = 0x02;
    char receivel[5];
    char receiver[5];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(DE0_handle, sendl, receivel, 5);
    lgSpiXfer(DE0_handle, sendr, receiver, 5);
    pthread_mutex_unlock(&spi_mutex);

    // left
    *tick_left = *((int32_t *)(&(receivel[1])));
    *tick_left = Reverse32(*tick_left);
    
    // right
    *tick_right = *((int32_t *)(&(receiver[1])));
    *tick_right = Reverse32(*tick_right);

}

void odo_reset() {
    char send[5]; send[0] = 0x7F;
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(DE0_handle, send, 5);
    pthread_mutex_unlock(&spi_mutex);
}

void odo_set_pos(double x, double y, double theta) {
    
    char sendx[5]; char sendy[5]; char sendt[5]; char sendr[5]; 
    float x_crop = (float) x, y_crop = (float) y, theta_crop = (float) theta;
    
    int32_t send_float;

    send_float = *((int32_t*)(&x_crop));
    sendx[0] = 0x90;
    sendx[1] = send_float >> 24;
    sendx[2] = (send_float & 0xFF0000) >> 16;
    sendx[3] = (send_float & 0xFF00) >> 8;
    sendx[4] = send_float & 0xFF;

    send_float = *((int32_t*) (&y_crop));
    sendy[0] = 0x91;
    sendy[1] = send_float >> 24;
    sendy[2] = (send_float & 0xFF0000) >> 16;
    sendy[3] = (send_float & 0xFF00) >> 8;
    sendy[4] = send_float & 0xFF;

    send_float = *((int32_t*) (&theta_crop));
    sendt[0] = 0x92;
    sendt[1] = send_float >> 24;
    sendt[2] = (send_float & 0xFF0000) >> 16;
    sendt[3] = (send_float & 0xFF00) >> 8;
    sendt[4] = send_float & 0xFF;

    sendr[0] = 0x7F;

    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(DE0_handle, sendx, 5);
    lgSpiWrite(DE0_handle, sendy, 5);
    lgSpiWrite(DE0_handle, sendt, 5);
    lgSpiWrite(DE0_handle, sendr, 5);
    pthread_mutex_unlock(&spi_mutex);
}

void odo_get_pos(double *x, double *y, double *theta){
    char sendx[5]; char sendy[5]; char sendt[5];
    char receivex[5]; char receivey[5]; char receivet[5];
    sendx[0] = 0x03; sendy[0] = 0x04; sendt[0] = 0x05;
    
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(DE0_handle, sendx, receivex, 5);
    lgSpiXfer(DE0_handle, sendy, receivey, 5);
    lgSpiXfer(DE0_handle, sendt, receivet, 5);
    pthread_mutex_unlock(&spi_mutex);

    int32_t receive_int;
    float *receive_float = (float*) &receive_int;

    receive_int = Reverse32(*(int32_t *)(&(receivex[1])));
    *x = (double) *receive_float;
    receive_int = Reverse32(*(int32_t *)(&(receivey[1])));
    *y = (double) *receive_float;
    receive_int = Reverse32(*(int32_t *)(&(receivet[1])));
    *theta = (double) *receive_float;
}

// ----- Sonars -----

/*
double sonar_ask() {

    lgTxPulse(sonar_GPIO_Trig, 11, 1);
    time_sleep(6e-2);

    char send[] = {0x05,0,0,0,0};
    char receive[5];
    spiXfer(DE0_handle, send, receive, 5);

    // Retrieve travel time (round trip time)
    uint32_t RTT = *((uint32_t*) &(receive[1]));
    RTT = Reverse32(RTT);
    return RTT*3.44e-6; // Compute distance from travel time (d = RTT*v_sound/2)

}

void init_sonar() {
    gpioSetMode(sonar_GPIO_Trig, PI_OUTPUT);
}*/

// ----- Teensy -----

void teensy_path_following(double *x, double *y, int ncheckpoints, double theta_start, double theta_end, double vref, double dist_goal_reached) {

    size_t message_size = sizeof(char)*2 + sizeof(uint16_t)*(2*ncheckpoints+4);
    // Send vector. Needs to be malloced since it is variable size
    char send[message_size];

    // Send the query over a single byte
    char *send_query = (char *) send;
    send_query[0] = (char) QueryDoPathFollowing;

    // Send the number of points over a single byte. Hence limited to 255 points
    char *send_n =(char *) (send_query + sizeof(char));
    send_n[0] = (char) ncheckpoints;
    
    // Send each points over two bytes
    uint16_t *send_points = (uint16_t *) (send_n + sizeof(char)); // Send points over 2 bytes   
    for (int i = 0; i < ncheckpoints; i++)              send_points[i] = (uint16_t) (UINT16_MAX*(x[i]/2.0));
    for (int i = 0; i < ncheckpoints; i++) send_points[i+ncheckpoints] = (uint16_t) (UINT16_MAX*(y[i]/3.0));
    send_points[2*ncheckpoints]   = (uint16_t) (UINT16_MAX*((theta_start+M_PI)/(M_PI*2)));
    send_points[2*ncheckpoints+1] = (uint16_t) (UINT16_MAX*((theta_end+M_PI)/(M_PI*2)));
    send_points[2*ncheckpoints+2] = (uint16_t) (UINT16_MAX*(vref/2.0));
    send_points[2*ncheckpoints+3] = (uint16_t) (UINT16_MAX*(dist_goal_reached/3.0));

    #ifdef VERBOSE
    char receive[message_size];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, message_size);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending path following\n");
    for (size_t i = 0; i < message_size; i++)
    {
        printf("%d, %d\n", send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, message_size);
    pthread_mutex_unlock(&spi_mutex);
    #endif
}

void teensy_set_position(double x, double y, double theta) {
    char send[7];
    send[0] = (char) QuerySetPosition; 
    
    uint16_t *send_ref = (uint16_t *) (send + sizeof(char));
    send_ref[0] = (uint16_t) (UINT16_MAX*(x/2.0));  // xr compressed
    send_ref[1] = (uint16_t) (UINT16_MAX*(y/3.0));  // yr compressed
    send_ref[2] = (uint16_t) (UINT16_MAX*((theta+M_PI)/(M_PI*2)));  // tr compressed

    #ifdef VERBOSE
    char receive[7];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, 7);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending Set Position\n");
    for (int i = 0; i < 7; i++)
    {
        printf("%d, %d\n",send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, 7);
    pthread_mutex_unlock(&spi_mutex);
    #endif
}

void teensy_pos_ctrl(double xr, double yr, double theta_r) {
    // Compression to go to SPI
    char send[7];
    send[0] = (char) QueryDoPositionControl; 
    
    uint16_t *send_ref = (uint16_t *) (send + sizeof(char));
    send_ref[0] = (uint16_t) (UINT16_MAX*(xr/2.0));  // xr compressed
    send_ref[1] = (uint16_t) (UINT16_MAX*(yr/3.0));  // yr compressed
    send_ref[2] = (uint16_t) (UINT16_MAX*((theta_r+M_PI)/(M_PI*2)));  // tr compressed

    #ifdef VERBOSE
    char receive[7];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, 7);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending Position ctrl \n");
    for (int i = 0; i < 7; i++)
    {
        printf("%d, %d\n",send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, 7);
    pthread_mutex_unlock(&spi_mutex);
    #endif
}


void teensy_spd_ctrl(double speed_left, double speed_right) {
    // Compression to go to SPI
    char send[5];
    send[0] = (char) QueryDoSpeedControl;

    uint16_t *send_ref = (uint16_t *) (send + sizeof(char));
    send_ref[0] = (uint16_t) ((speed_left/2.0)*UINT16_MAX);   // speed_left compressed
    send_ref[1] = (uint16_t) ((speed_right/2.0)*UINT16_MAX);   // speed_right compressed

    #ifdef VERBOSE
    char receive[5];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, 5);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending Speed ctrl \n");
    for (int i = 0; i < 5; i++)
    {
        printf("%d, %d\n",send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, 5);
    pthread_mutex_unlock(&spi_mutex);
    #endif
    
}

void teensy_constant_dc(int dc_refl, int dc_refr) {
    // Compression to go to SPI
    char send[5];
    send[0] = (char) QueryDoConstantDutyCycle;
    uint16_t *send_ref = (uint16_t*) (send + sizeof(char));
    send_ref[0] = (uint16_t) (((double) SATURATE(dc_refl, -255,255))+255.0);  // speed_left compressed
    send_ref[1] = (uint16_t) (((double) SATURATE(dc_refr, -255, 255))+255.0);   // speed_right compressed

    #ifdef VERBOSE
    char receive[5];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, 5);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending constant DC ctrl \n");
    for (int i = 0; i < 5; i++)
    {
        printf("%d, %d\n",send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, 5);
    pthread_mutex_unlock(&spi_mutex);
    #endif
}

void teensy_idle() {
    char send = (char) QueryIdle;
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, &send, 1);
    pthread_mutex_unlock(&spi_mutex);
}

int teensy_ask_mode() {
    char send[4];
    char receive[4];
    send[0] = QueryAskState;
    send[1] = 0; // Not needed
    send[2] = 1; // Not needed
    send[3] = 2; // Not needed
    pthread_mutex_lock(&spi_mutex);
    int retval = lgSpiXfer(Teensy_handle, send, receive, 4);
    pthread_mutex_unlock(&spi_mutex);
    #ifdef VERBOSE
    printf("Asking state\n");
    printf("Xfer return value: %d\n", retval);
    for (int i = 0; i < 4; i++){
        printf("%d, %d\n", send[i], receive[i]);
    }
    #endif
    return (int) receive[2];
}

void teensy_set_position_controller_gains(double kp, double ka, double kb, double kw) {
    // Compression to go to SPI
    int message_size = 1 + 2*4;
    char send[9];
    send[0] = (char) QuerySetPositionControlGains;

    uint16_t *send_ref = (uint16_t *) (send + sizeof(char));
    send_ref[0] = (uint16_t) ((kp/20)*UINT16_MAX);   // speed_left compressed
    send_ref[1] = (uint16_t) ((ka/20)*UINT16_MAX);   // speed_right compressed
    send_ref[2] = (uint16_t) ((-kb/20)*UINT16_MAX);   // speed_right compressed
    send_ref[3] = (uint16_t) ((kw/50)*UINT16_MAX);   // speed_right compressed

    #ifdef VERBOSE
    char receive[9];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, message_size);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending Speed ctrl \n");
    for (int i = 0; i < message_size; i++)
    {
        printf("%d, %d\n",send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, message_size);
    pthread_mutex_unlock(&spi_mutex);
    #endif
}

void teensy_set_path_following_gains(double kt, double kn, double kz, double sigma, double epsilon, double kv_en, double delta, double wn) {
    // Compression to go to SPI
    int message_size = 1 + 2*8;
    char send[17];
    send[0] = (char) QuerySetPathFollowerGains;

    uint16_t *send_ref = (uint16_t *) (send + sizeof(char));
    send_ref[0] = (uint16_t) ((kt/50)*UINT16_MAX);   // speed_left compressed
    send_ref[1] = (uint16_t) ((kn)*UINT16_MAX);   // speed_right compressed
    send_ref[2] = (uint16_t) ((kz/200)*UINT16_MAX);   // speed_right compressed
    send_ref[3] = (uint16_t) ((sigma/20)*UINT16_MAX);   // speed_right compressed
    send_ref[4] = (uint16_t) ((epsilon)*UINT16_MAX);   // speed_left compressed
    send_ref[5] = (uint16_t) ((kv_en/100)*UINT16_MAX);   // speed_right compressed
    send_ref[6] = (uint16_t) ((delta)*UINT16_MAX);   // speed_right compressed
    send_ref[7] = (uint16_t) ((wn/100)*UINT16_MAX);   // speed_right compressed

    

    #ifdef VERBOSE
    char receive[17];
    pthread_mutex_lock(&spi_mutex);
    lgSpiXfer(Teensy_handle, send, receive, message_size);
    pthread_mutex_unlock(&spi_mutex);
    printf("Sending Speed ctrl \n");
    for (int i = 0; i < message_size; i++)
    {
        printf("%d, %d\n",send[i], receive[i]);
    }
    #else
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(Teensy_handle, send, message_size);
    pthread_mutex_unlock(&spi_mutex);
    #endif
}


// ----- Flaps servomotors -----

void flaps_servo_cmd(flaps_servo_cmd_t command) {
    char send[5];
    send[0] = 0x80;
    uint16_t servo_flaps1_duty_cycle; 
    uint16_t servo_flaps2_duty_cycle; 

    switch (command)
    {

    case FlapsIdle: 
        servo_flaps1_duty_cycle = 0;
        servo_flaps2_duty_cycle = 0;
        break;

    case FlapsDeploy:
        servo_flaps1_duty_cycle = 680;
        servo_flaps2_duty_cycle = 620;
        break;
    
    case FlapsRaise:
        servo_flaps1_duty_cycle = 500;
        servo_flaps2_duty_cycle = 800;
        break;

    default:
        return;
    }
    send[1] = (servo_flaps1_duty_cycle & 0xFF00) >> 8;
    send[2] = servo_flaps1_duty_cycle & 0xFF;

    send[3] = (servo_flaps2_duty_cycle & 0xFF00) >> 8;
    send[4] = servo_flaps2_duty_cycle & 0xFF;
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(DE0_handle, send, 5);
    pthread_mutex_unlock(&spi_mutex);
}

void gripper_holder_cmd(gripper_holder_cmd_t command) {
    char send[5];
    send[0] = 0x8E;
    uint16_t servo_holder_duty_cycle; 
    switch (command) {
        case HolderIdle:
            servo_holder_duty_cycle = 0;
            break; 

        case HolderClosed:
            servo_holder_duty_cycle = 635;
            break; 

        case HolderOpen:
            servo_holder_duty_cycle = 860;
            break;

        case HolderPot:
            servo_holder_duty_cycle = 725;
            break;

        case HolderPlant:
            servo_holder_duty_cycle = 670;
            break;

        default:
            return;
    }
    send[3] = (servo_holder_duty_cycle & 0xFF00) >> 8;
    send[4] = servo_holder_duty_cycle & 0xFF;
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(DE0_handle, send, 5);
    pthread_mutex_unlock(&spi_mutex);
}

void gripper_deployer_cmd(gripper_deployer_cmd_t command) {
    char send[5];
    send[0] = 0x8F;
    uint16_t servo_deployer_duty_cycle; 
    switch (command) {
        case DeployerIdle:
            servo_deployer_duty_cycle = 0;
            break; 

        case DeployerRaise:
            servo_deployer_duty_cycle = 850;
            break;

        case DeployerHalf:
            servo_deployer_duty_cycle = 650;
            break;

        case DeployerDeploy:
            servo_deployer_duty_cycle = 450;
            break;

        default:
            return;
    }
    send[3] = (servo_deployer_duty_cycle & 0xFF00) >> 8;
    send[4] = servo_deployer_duty_cycle & 0xFF;
    pthread_mutex_lock(&spi_mutex);
    lgSpiWrite(DE0_handle, send, 5);
    pthread_mutex_unlock(&spi_mutex);
}
