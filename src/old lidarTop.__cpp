// #include "lidarTop.h"
// #include <chrono>

// <<<<<<< HEAD
// ///pour dif un full scan d'un scan full en connaissant sa precedence position
// bool premierScan = true;
// =======
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8

// ///global variable to find out the size of the file
// size_t arraySize = 8000;

// <<<<<<< HEAD
// int debuglidardemerde = 0;

// ///taille balise
// =======

// ///size beacon
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
// double largeurMatAdvers = 0.17;

// ///useful for print
// bool analyseDetail = false;
// bool analyseDetail_objet = false;
// bool analyseRotationBalise = false;


// <<<<<<< HEAD
// ///double tolerance sur le bord de la table
// double tolTable = 0.05;

// ///dimension de la table
// =======
// ///tolerance on the edge of the table
// double tolTable = 0.05;

// ///table size
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
// double tableX = 2 + tolTable;
// double tableY = 3 + tolTable;
// double minTableX = - tolTable;
// double minTableY = - tolTable;

// <<<<<<< HEAD
// ///tolerance pour eviter de prendre les balises pour des adversaires
// double tolBalise = 0.1;

// /**
//  * We calculate the position of the robot in beacon reference
//  * from the polar coordinates of the 3 beacons and knowing that the robot is at the origin of the reference frame,
//  * we recover the coordinates of the robot in (x,y) according to the reference frame determined with beacon 3 in (0,0).
//  *
//  * @param db : distance between beacons 2 by 2
//  * @param x : positions of the beacons in x (reference robot (0;0)
//  * @param y : positions of the beacons in y (reference robot (0;0)
//  * @param lidarData : structure where we can save the position
//  * @param anglesBeacons : angle between the robot and the beacons
//  * Save beacon such that :
//  * ---------D1---------
//  * |                  |
//  * |                  |
//  * |                  |
//  * |                  |
//  * |                  |
//  * D3----------------D2
//  * (0,0)
//  */
// void rotationPosition(double *db, double *x, double *y, LidarData *lidarData, double *anglesBeacons) {
//     double *beacon1;
//     double *beacon2;
//     double *beacon3;

//     ///in the current reference of the beacons, the robot is in (0,0)
//     lidarData->x_robot = 0.0;
//     lidarData->y_robot = 0.0;
//     double orientation;

//     for (int i = 0; i < 3; ++i) {
//         if (std::abs(db[(i + 2) % 3] - db[(i + 1) % 3]) < 0.36) {
//             //we will always have this condition met 1 time, otherwise we would not have used the function
//             beacon1 = new double[2]{x[i], y[i]};
//             beacon2 = new double[2]{x[(i + 1) % 3], y[(i + 1) % 3]};
//             beacon3 = new double[2]{x[(i + 2) % 3], y[(i + 2) % 3]};

//             ///to determine the orientation of the robot on the table relative to beacon3
//             orientation = anglesBeacons[(i + 2) % 3];
//         }
//     }

//     ///Transformation so that D3 is in 0.0
//     ///save transfo
//     lidarData->transfo_x = beacon3[0];
//     lidarData->transfo_y = beacon3[1];

//     beacon2[1] -= beacon3[1];
//     lidarData->y_robot -= beacon3[1];

//     beacon2[0] -= beacon3[0];
//     lidarData->x_robot -= beacon3[0];
//     if (analyseRotationBalise) {
//         beacon1[1] -= beacon3[1];
//         beacon3[1] -= beacon3[1];

//         beacon1[0] -= beacon3[0];
//         beacon3[0] -= beacon3[0];
//     }

//     ///calculating the angle of rotation for the second transformation
//     double alpha = -atan2(beacon2[1], beacon2[0]);

//     ///save transfo
//     lidarData->transfo_a = alpha;

//     ///Rotation so that the table is in positive x, y
//     double xtemp;
//     double ytemp;

//     if (analyseRotationBalise) {
//         xtemp = beacon2[0];
//         ytemp = beacon2[1];
//         beacon2[0] = cos(alpha) * xtemp - sin(alpha) * ytemp;
//         beacon2[1] = sin(alpha) * xtemp + cos(alpha) * ytemp;

//         xtemp = beacon1[0];
//         ytemp = beacon1[1];
//         beacon1[0] = cos(alpha) * xtemp - sin(alpha) * ytemp;
//         beacon1[1] = sin(alpha) * xtemp + cos(alpha) * ytemp;
//     }

//     xtemp = lidarData->x_robot;
//     ytemp = lidarData->y_robot;
//     lidarData->x_robot = cos(alpha) * xtemp - sin(alpha) * ytemp;
//     lidarData->y_robot = sin(alpha) * xtemp + cos(alpha) * ytemp;

//     ///to determine the orientation of the robot on the table
//     lidarData->orientation_robot = moduloLidarMPIPI(
//             -M_PI / 2.0 + orientation - atan2(lidarData->x_robot, lidarData->y_robot));

//     delete[] (beacon1);
//     delete[] (beacon2);
//     delete[] (beacon3);
//     return;

// }
// =======
// ///tolerance to avoid mistaking beacons for opponents
// double tolBalise = 0.1;

// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8

// /**
//  * if we don't found adversary from previous data we check everywhere
//  * @param angles array with angle in radian from lidar
//  * @param distances array with distances in m from lidar
//  * @param lidarData structure with previous data and where we save current data
//  */

// int foundAdvWithOdo(double *anglesAdv, double *distancesAdv, LidarData *lidarData) {
//     //recalculates transformations to find the opponent
//     ///transfo contains 4 elem : deltaX, deltaY, angle of rotation, the number of elements in possible opponents (number of elements in *anglesAdv)
//     int size = lidarData->countObj_adv;

//     ///coordinates in xy after one and two transformations (translations then rotation)
//     double xobj;
//     double yobj;
// <<<<<<< HEAD
//     double minDistAuCentre = 5.0;
//     double minDistRobot = 5.0;
//     for (int i = 0; i < size; ++i) {
        
// =======
// 	double minDistAuRobot = 5.0;

//     for (int i = 0; i < size; ++i) {
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//         /// transformation identical to that of beacons and robots
//         double gamma = lidarData->orientation_robot - anglesAdv[i];
//         xobj = lidarData->x_robot + distancesAdv[i] * std::cos(gamma);
//         yobj = lidarData->y_robot + distancesAdv[i] * std::sin(gamma);
//         if (xobj > minTableX && xobj < tableX) {
            
//             ///check whether the y coordinate is valid (on the table)
//             ///deplacement de l'adversaire
// <<<<<<< HEAD
//             //double depl = sqrt(deltX*deltX+deltY*deltY);
// =======
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//             if (yobj > minTableY && yobj < tableY) {
//                 bool premcondition = (yobj < tolBalise) && ((xobj < tolBalise) || (abs(xobj - 1) < tolBalise) || (xobj > 2 - tolBalise)); // 
//                 bool seccondition = (yobj > 3 - tolBalise) && ((xobj < tolBalise) || (abs(xobj - 1) < tolBalise) || (xobj > 2 - tolBalise));
//                 bool troicondition = (abs(yobj - 1.5) < 0.5) && xobj < 0.18;
//                 if (!(premcondition || seccondition || troicondition)) {
//                     /// if the object is on the table, it's our opponent,
//                     /// we save its coordinates in the new base (xy based on beacon3)
//                     /// and the original coordinates (relative to the robot, distance and angle)
// <<<<<<< HEAD
//                     double dist = hypot((xobj - 1.0), (yobj - 1.5));
//                     double distRobot = hypot((xobj - lidarData->x_robot), (yobj - lidarData->y_robot));
//                     //if (minDistAuCentre > dist) {
//                     //printf("condition %f %f\n", minDistRobot, distRobot);
//                     if (minDistRobot > distRobot){
// =======
//                     double dist = hypot((xobj - lidarData->x_robot), (yobj - lidarData->y_robot));
//                     if (minDistAuRobot > dist) {
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//                         lidarData->x_adv = xobj;
//                         lidarData->y_adv = yobj;
//                         lidarData->d_adv = distancesAdv[i];
//                         lidarData->a_adv = anglesAdv[i];
// <<<<<<< HEAD
//                         //minDistAuCentre = dist;
//                         minDistRobot = distRobot;
//                         //printf("mindistRobot %f\n", minDistRobot);
// =======
//                         minDistAuRobot = dist;
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//                     }
//                     //TODO check minDistRobot vs min

//                 }
//                 /// we assume that the lidar can only see one object on the table
//                 /// and that it is therefore automatically the robot
//             }
//         }
//     }
//     /// We haven't found the opponent, by default the coordinates remain in 0
// <<<<<<< HEAD
//     // printf("Adversary found at (%f,%f)\n", lidarData->x_adv, lidarData->y_adv);
// =======
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//     return 1;
// }

// /**
//  * From the raw lidar data, save in lidarData the coordinates of the robot according to the defined plane and the coordinates of the opponent
//  * @param angles : array of size max 8192 with angle in degree
//  * @param distances : array of size max 8192 with distances in m
//  * @param quality : array of size max 8192 with quality
//  * @param lidarData : structure with useful data (previous data) and where we save the new data
//  * @param fullScan : if true: performs a full scan with no position prediction,
//  *                  if false: performs a more accurate scan, mimicked by an estimate of the position of the beacons and the opponent
//  *
//  * if (fullScan) we need data in lidarData->beaconAdv : table of 8 with the angles and distances of the 3 beacons and the opponent (a1, d1, a2, d2, a3, d3, a, d)
//  *   __________1_________
//  *  |                   |
//  *  |                   |
//  *  |                   |
//  *  |                   |
//  *  |                   |
//  *  |___________________|
//  * 3                    2
//  *
//  * Beacon 3 at (0,0)
//  */
// void checkBeacon(double *angles, double *distances, double *quality, LidarData *lidarData, bool fullScan) {
//     ///par défaut a 3.55 mais peut être diminuer en fonction des distances des balises précédentes
//     double distMax = 3.6;

//     ///objet==true : object detected at probable distance
//     bool objet = false;

//     ///distance and angle of the first and last points of an object
//     double d1 = 0;
//     double d2 = 0;
//     double a1 = 0;
//     double a2 = 0;

//     /// size of detected object
//     double size;

//     /// list of objects that are possible beacon
//     double *dObj_adv = new double[arraySize];
//     double *aObj_adv = new double[arraySize];

//     /// number of items in list
//     int countObj_adv = 0;

//     /// count of missing data+1
//     /// useful for knowing the difference in maximum distance when a lot of data is lost between 2 elements
//     int countGap = 1;
//     for (int i = 0; i < arraySize; ++i) {
//         /// check if the object is potentially on the table
//         if (0.1 < distances[i] && distances[i] < distMax) {
//             /// no previous object: a new object to be initialized
//             if (!objet) {
//                 objet = true;
//                 a1 = angles[i];
//                 d1 = distances[i];
				
//             } else {
//                 // object present before: if distance small enough it's the same (delta<2cm) -> nothing to do
//                 // delta >3cm : new object -> check if the previous one is a beacon
//                 if (std::abs(d2 - distances[i]) > 0.03) {
//                     //what we detect is a new object

//                     ///size of object previously detected
//                     size = std::sqrt(d2 * d2 + d1 * d1 - 2 * d2 * d1 * std::cos(a2 - a1));
//                     ///a beacon on an opponent can be larger
//                     if (size < largeurMatAdvers) {
//                         aObj_adv[countObj_adv] = (a1 + a2) / 2;
//                         dObj_adv[countObj_adv] = (d1 + d2) / 2;
//                         countObj_adv++;
//                     }
//                     /// new object : initial values are stored
//                     d1 = distances[i];
//                     a1 = angles[i];
//                 }
//             }
//             /// distance ok -> next object: update current end values
//             d2 = distances[i];
//             a2 = angles[i];

//             /// we have an element so there are no data gaps
//             countGap = 1;

//         } else if ((distances[i] != 0) && objet) {
//             // if outside desired distance :
//             //  - either 0 (not taken into account: possible lack of values in data capture)
//             //   -object too far away
//             //      -> end of object (objet==true : same as above)
//             //      -> no previous object : nothing to do
//             size = std::sqrt(d2 * d2 + d1 * d1 - 2 * d2 * d1 * std::cos(a2 - a1));

//             if (size < largeurMatAdvers && d1 > 0) {
//                 aObj_adv[countObj_adv] = (a1 + a2) / 2;
//                 dObj_adv[countObj_adv] = (d1 + d2) / 2;
//                 countObj_adv++;
//             }
//             d1 = 0;
//             d2 = 0;
//             a1 = 0;
//             a2 = 0;
//             objet = false;
//             countGap = 1;
//         } else if (distances[i] == 0) {
//             countGap += 1;
//             if (countGap > 5) {
//                 if (objet) {
//                     size = std::sqrt(d2 * d2 + d1 * d1 - 2 * d2 * d1 * std::cos(a2 - a1));
//                     if (size < largeurMatAdvers && d1 > 0) {
//                         aObj_adv[countObj_adv] = (a1 + a2) / 2;
//                         dObj_adv[countObj_adv] = (d1 + d2) / 2;
//                         countObj_adv++;
//                     }
//                     d1 = 0;
//                     d2 = 0;
//                     a1 = 0;
//                     a2 = 0;
//                     objet = false;
//                     countGap = 1;
//                 }
//             }
//         }
//     }
//     lidarData->countObj_adv = countObj_adv;
//     foundAdvWithOdo(aObj_adv, dObj_adv, lidarData);
//     return;
// }

// void lidarGetRobotPosition(LidarData *lidarData, int i, bool fullScan, bool fromOdo) {
//     lidarData->readLidar_lost = false;
//     lidarData->old_transfo_x = lidarData->x_adv;
//     lidarData->old_transfo_y = lidarData->y_adv;
//     double *angles = new double[8000];
//     double *distances = new double[8000];
//     double *quality = new double[8000];
//     size_t *as = new size_t[2]{8000, 8000};

// 	lidarData->orientation_robot = lidarData->theta_odo;
// 	lidarData->x_robot = lidarData->x_odo + 0.1 * cos(lidarData->orientation_robot);
// <<<<<<< HEAD
// 	lidarData->y_robot = lidarData->y_odo + 0.1 * sin(lidarData->orientation_robot);//TODO PAULINE 0.2+ ??

//     updateDataTop(angles, distances, quality, as);
//     arraySize = as[0];
//     //DataToFileTop("polar.txt");
// =======
// 	lidarData->y_robot = lidarData->y_odo + 0.1 * sin(lidarData->orientation_robot);

//     updateDataTop(angles, distances, quality, as);
//     arraySize = as[0];
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8

//     if (analyseDetail) {
//         printf("size : %ld\n", as[0]);
//     }
//     if (i == 0) {
//         fullScan = true;
//     }
//     checkBeacon(angles, distances, quality, lidarData, fullScan);


//     delete[] (angles);
//     delete[] (distances);
//     delete[] (quality);
//     delete[] (as);
//     if (!lidarData->readLidar_lost) {
// <<<<<<< HEAD
//         //2 des positions pour être centré au niveau des roues sauf la distance et l'angle de l'adversaire
// 		///save Data
// 		lidarData->readLidar_x_robot = lidarData->x_robot - 0.1 * cos(lidarData->orientation_robot);
// 		lidarData->readLidar_y_robot = lidarData->y_robot - 0.1 * sin(lidarData->orientation_robot);
// =======
//         //2 of the positions to be centred at wheel level except the distance and angle of the opponent
// 		///save Data
// 		lidarData->readLidar_x_robot = lidarData->x_robot - 0.1 * cos(lidarData->orientation_robot);//plus utile
// 		lidarData->readLidar_y_robot = lidarData->y_robot - 0.1 * sin(lidarData->orientation_robot);//plus utile
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
// 		lidarData->readLidar_theta_robot = moduloLidarMPIPI(lidarData->orientation_robot);
// 		lidarData->readLidar_x_opponent = lidarData->x_adv;
// 		lidarData->readLidar_y_opponent = lidarData->y_adv;
// 		lidarData->readLidar_d_opponent = lidarData->d_adv;
// 		lidarData->readLidar_a_opponent = moduloLidarMPIPI(-lidarData->a_adv);

// 		///Save old
//         lidarData->old_transfo_x = lidarData->transfo_x;
//         lidarData->old_transfo_y = lidarData->transfo_y;
//         lidarData->old_transfo_a = lidarData->transfo_a;

//     } else {
//         //if the robot is lost: 2 possibilities:
//         // -either it can't spot the opponent at all (d_adv set to 400m by default)
//         // -or it can find its way thanks to the odo and recognises the opponent anyway → in which case the condition below applies.
//         if (lidarData->d_adv < 100) {
// <<<<<<< HEAD
// 			printf("aaaaaaaaaaaaaaaaah ne doit pas rentrer ici !");
// =======
// 			//normally never enters here
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//             lidarData->readLidar_d_opponent = lidarData->d_adv;
//             lidarData->readLidar_a_opponent = lidarData->a_adv;
// 			lidarData->readLidar_x_opponent = lidarData->x_adv;
// 			lidarData->readLidar_y_opponent = lidarData->y_adv;

//         }
//     }
// <<<<<<< HEAD
//     premierScan = false;
// =======
// >>>>>>> 9f2ea974f4ae6ef9b7690c777c3e68b0250e3cb8
//     lidarData->readLidar_lost=true;

// }

// void init_lidar(LidarData *lidarData) {
//     lidarData->readLidar_x_robot = 0.0;
//     lidarData->readLidar_y_robot = 0.0;
//     lidarData->readLidar_theta_robot = 0.0;
//     lidarData->readLidar_x_opponent = 400.0;
//     lidarData->readLidar_y_opponent = 0.0;
//     lidarData->readLidar_d_opponent = 400.0;
//     lidarData->readLidar_a_opponent = 0.0;
//     lidarData->readLidar_lost = true;


//     lidarData->transfo_a = 0;
//     lidarData->transfo_x = 0;
//     lidarData->transfo_y = 0;

//     lidarData->countObj_adv = 0;

//     lidarData->x_robot = 0.0;
//     lidarData->y_robot = 0.0;
//     lidarData->orientation_robot = -M_PI / 2;

//     lidarData->x_adv = 400;
//     lidarData->y_adv = 0;
//     lidarData->d_adv = 400;
//     lidarData->a_adv = 0;

//     lidarData->beaconAdv = new double[8]{0, 0, 0, 0, 0, 0, 0, 0};

//     lidarData->x_odo = 0.0;
//     lidarData->y_odo = 0.0;
//     lidarData->theta_odo = 0.0;

//     lidarData->old_x_adv = 0.9;
//     lidarData->old_y_adv = 0.9;
//     return;
// }

// void clear_lidar(LidarData *lidarData) {
//     delete[] (lidarData->beaconAdv);
//     delete[] (lidarData);
// }
